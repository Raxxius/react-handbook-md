{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Baw Medical React Handbook - Patterns and Design Style","text":""},{"location":"#1-technology-stack","title":"1. Technology Stack:","text":"<p>Utilize Vite as the project setup tool, JavaScript as the primary language, Babel for transpilation, ESLint for code linting, Prettier for code formatting, and Jest for testing within React projects.</p>"},{"location":"#2-folder-structure-and-micro-frontend-design-pattern","title":"2. Folder Structure and Micro Frontend Design Pattern:","text":"<p>Adopt a recommended folder structure, following the Micro Frontend design pattern for better organization and scalability.</p>"},{"location":"#3-react-component-structure","title":"3. React Component Structure:","text":"<p>Structure React components using SOLID programming principles, emphasizing Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.</p>"},{"location":"#4-compartmentalization-and-micro-frontend-design","title":"4. Compartmentalization and Micro Frontend Design:","text":"<p>Embrace the concept of compartmentalization in line with Micro Frontend design. Break down large components into smaller, more manageable subcomponents, enhancing modularity and reusability.</p>"},{"location":"#5-separation-of-concerns","title":"5. Separation of Concerns:","text":"<p>Implement separation of concerns via well-defined component layers. Logic layer handles state and business logic, Display layer manages UI rendering, Component layer orchestrates the overall structure, and Subcomponents handle specific UI elements or functionalities.</p>"},{"location":"#6-functional-components-and-es6-syntax","title":"6. Functional Components and ES6 Syntax:","text":"<p>Prefer using functional components over class components. Leverage ES6 syntax for concise and expressive code.</p>"},{"location":"#7-props-and-state","title":"7. Props and State:","text":"<p>Prioritize the use of variables passed via props over maintaining state within subcomponents. Reserve state for the necessary layers such as the global, page, or parent component. State should be stored at the appropiate layer to ensure readability of code. </p>"},{"location":"#8-basic-file-structure","title":"8. Basic File Structure:","text":"<p>Establish a clear file structure that follows the progression of component layers - Logic layer (handles state and logic), Display layer (manages UI rendering), Component layer (orchestrates structure), and SubComponent layer(s) (handles specific UI elements).</p>"},{"location":"#9-styling-and-css","title":"9. Styling and CSS:","text":"<p>CSS is to be stored at three levels: global, page, and component. Component-level CSS is to be stored in CSS modules to avoid potential conflicts and unintended side effects.</p>"},{"location":"#summary","title":"Summary","text":"<p>By adhering to these guidelines, Baw Medical can create React components and projects that are not only well-structured and maintainable but also align with modern best practices and industry standards.</p>"},{"location":"docsncomments/","title":"Documentation and Comments","text":"<p>Accurate documentation is critical for</p> <p>Well-paced comments in code are crucial for maintaining a clear and structured codebase.</p>"},{"location":"docsncomments/#essential-documents","title":"Essential Documents","text":"<p>It is essential to have a document with all used depencencies and working version, while this information can be gleened from the package-lock.js this file can become quite verbose as it includes all react depencies such as babel.</p>"},{"location":"docsncomments/#comments-in-code","title":"Comments in code","text":"<p>The preference is to comment code with short concise statements that improve clarity and allow for new contributors to quickly establish the </p> <p>Comments are also used to organise React.jsx files. </p>"},{"location":"docsncomments/#comments-at-start-of-functionjsx-files","title":"Comments at start of function.jsx files","text":"<p>A brief paragaph at comment at the start of function.js files should provide an overview of the file's purpose, inputs, functionality and other relevant details.</p> <p>Also do this for subcomponents.</p> <p>Example:</p> <pre><code>    checkLogin.js\n    /**\n    * Manages login functionality through API integration.\n    * \n    * Function:\n    * - `handleLogin`: Processes login request, integrating with an API.\n    * \n    * Input Variables:\n    * - `username`: Login username.\n    * - `password`: Login password.\n    * \n    * Output:\n    * - Returns `true` on successful login, `false` otherwise.\n    */\n\n    import React from 'react';\n    import API from './api.js';\n\n    const checkLogin = ({ username, password }) =&gt; {\n    // Rest of the code\n    };\n</code></pre>"},{"location":"docsncomments/#comments-in-jsx-files","title":"Comments in jsx files","text":"<p>Use of comments to organise code sections of React components.</p> <p>Example:</p> <pre><code>    const ExampleApp = () =&gt; {\n    /** Props Destructring */\n    // if props are passed down as 'props', destructure them first\n\n    /** State */\n    // UseState should be defined here\n\n    /** Custom State Functions (generally use imports)*/\n    // state functions\n\n    /** useEffect hooks */\n    // useEffects here to setup state\n\n    /** core return */\n    return (\n        //return code.\n    )\n    }\n</code></pre>"},{"location":"folders/","title":"Folder Structure","text":"<p>When organising a new React Project, please adhere to the following folder structure</p> <pre><code>  \u251c\u2500\u2500 node_modules\n  \u251c\u2500\u2500 public\n  \u2514\u2500\u2500 src\n    \u251c\u2500\u2500 _api\n    \u251c\u2500\u2500 _tests\n    \u251c\u2500\u2500 _docs\n    \u251c\u2500\u2500 assets\n    \u251c\u2500\u2500 components\n    | \u2514\u2500\u2500 subcomponents\n    \u251c\u2500\u2500 pages\n    \u2514\u2500\u2500 hooks\n</code></pre>"},{"location":"folders/#folder-composition","title":"Folder composition","text":"<p>Please use the folders in the following order</p>"},{"location":"folders/#_api","title":"_api","text":"<p>the API folder contains all logic</p> <p>prefer use of async await Fetch requests to call API data</p> <p>example</p> <pre><code>async function exampleFetchApi() {\nconst response = await fetch(\"url to be fetched\");\n\nconst data = await response.json();\nreturn data;\n}\n</code></pre>"},{"location":"folders/#_test","title":"_test","text":"<p>Store all unit tests in the _test folder</p>"},{"location":"folders/#_docs","title":"_docs","text":"<p>docs are to be stored in markDown as .md files.</p> <p>critical docs that are needed </p> <ol> <li>dependencies.md - All dependencies that are installed need to be noted in this file in the following format</li> </ol> <pre><code>[ExampleDependency](url of example dependency)\nused in exampleFunction.js ExampleComponent\n*purpose of dependency*\n</code></pre>"},{"location":"folders/#assets","title":"assets","text":"<p>store all assets e.g. images/logos in the assets folder</p>"},{"location":"folders/#components","title":"components","text":"<p>Component folder should contain all components for the project, this includes anything that's not a custom hook or an API. </p> <p>React components should be written in CapitalCase.jsx files. non-react components should be in camelCase.js files.</p> <p>For complex components requring numerous unique subcomponents a subcomponent folder of the name of the primary component should be created.</p> <p>In the case of a large number of generic sub components (e.g. a styled button), a subcomponent folder can be created.</p>"},{"location":"folders/#pages","title":"pages","text":"<p>When mangaging the display of multiple components a display layer is prefered to using the App.jsx file</p> <p>Page files should be written in .jsx and named in CaptialCase.jsx</p>"},{"location":"folders/#hooks","title":"hooks","text":"<p>Any custom hooks can be stored in this folder.</p>"},{"location":"folders/#other-folders","title":"Other folders","text":"<p>If other folders are required for any reason make a note in the docs folder. </p>"},{"location":"functionalcomponents/","title":"React Components Overview","text":"<ol> <li>React components should be written as functional components</li> <li>Large components should be broken into subcomponents</li> <li>Subcomponents should be stateless</li> <li>Stateless components should be written as arrow functions for concise code.</li> </ol>"},{"location":"functionalcomponents/#functional-components","title":"Functional Components","text":"<p>React components are best written as functional components. The preferred syntax is to use arrow functions, especially for stateless components where implicit returns contribute to more concise code.</p>"},{"location":"functionalcomponents/#destructuring-props","title":"Destructuring props","text":"<p>Always destructure props rather than use props.var, this makes it easier to read what is being passed to the component. Either destructure the props in the function()(prefered) or as a first variable. e.g.</p> <p>preferred:</p> <pre><code>    const Component1 = ({time, date}) =&gt; (\n        &lt;div&gt;{time} {date}&lt;/div&gt;\n    )\n</code></pre> <p>alternative:</p> <pre><code>    const Component1 = (props) =&gt; {\n        const {time, date} = props\n        return (\n            &lt;div&gt;{time} {date}&lt;/div&gt;\n        )\n    }\n</code></pre> <p>The preferred approach, directly destructuring within the function parameters, is generally recommended for its brevity and clarity and in the case of SubComponents allows for direct returns. However, the alternative approach, destructuring as the first step inside the function body, is also acceptable and might be preferred in certain scenarios.</p> <p>This practice ensures a standardized and easily understandable way of handling props, contributing to a more consistent and readable codebase.</p>"},{"location":"functionalcomponents/#subcomponents","title":"Subcomponents","text":"<p>React subcomponents should be composed via Arrow functions, with props passed from a the parent. </p> <p>React states should not be set in subcomponent layers. </p> <p>example stateless component:</p> <pre><code>    const Component1 = ({ count, updateCount }) =&gt; (\n        &lt;div className=\"count-controller-box\"&gt;\n            &lt;p className=\"count-text\"&gt;count is {count}&lt;/p&gt;\n            &lt;button onClick={() =&gt; updateCount(count + 1)}&gt;+1&lt;/button&gt;\n            &lt;button onClick={() =&gt; updateCount(count - 1)}&gt;-1&lt;/button&gt;\n        &lt;/div&gt;\n    );\n</code></pre> <p>In this component the props count (a number) and updateCount (a function that uses parent state). The use of an Arrow function allows for an implicit return.</p>"},{"location":"patterns/","title":"Project Files Desgin Patterns","text":"<p>Projects, components and subcomponents should adhere to SOLID progamming principles when applicable. </p> <p>Files should be layered to seperate concerns, the general page design pattern is:</p> <pre><code>flowchart TD;\n\nA[LogicLayer.jsx]\nA --&gt; B\nB[DisplayLayer.jsx] --&gt; C\nC[ComponentLayer.jsx] --&gt; D\nC --&gt; E\nD[SubComponentLayer.jsx]\nE[SubComponentLayer.jsx]\nF[SubComponentLayer.jsx]\nB --&gt; G[ComponentLayer.jsx] --&gt; F[SubComponentLayer.jsx]\n</code></pre>"},{"location":"patterns/#logiclayerjsx","title":"LogicLayer.jsx","text":"<p>The primary role of Logic Layers state management, display logic.</p> <p>Example Logic layers would be the App.jsx file, Page.jsx files in multipage projects, and Component.jsx files in complex components with their own state and subcomponents.</p> <p>Use the Logic layer as a Storage global state and for making global API calls.</p> <p>Logic should remain pure, emphasising clean modular structuring in adherence to best practices.</p> <p>Logic should only be concerned with the logic flow, and abstain from direct code implementation within the flow, rather functions should be called, promoting separation of concerns.</p> <p>Basic layout styling is handled at this layer via the return statement.</p> <p>Segregating responsibilities in this manner allows the Logic layers to be maintainable, scalable and modular.</p>"},{"location":"patterns/#displaylayerjsx","title":"DisplayLayer.jsx","text":"<p>The display layer is used when page views are required. In this layer components are called and page specific state stored.</p> <p>Display layers' primary concern is display of components on the page.</p> <p>Logic can be present in the display layer, but this should be kept to the minimum, for example, in the react fragment return value if different components are displayed dependent upon state.</p> <p>Generally speaking this layer should remain relatively small.</p>"},{"location":"patterns/#component-layer","title":"Component layer","text":"<p>Treating React Components as Micro Frontends allows for compartmentalisation of code and isolation of interests between components. In this design pattern each component is isolated from others. This allows for modularity and reusability of </p> <p>Component layers can use state and logic that is component specific, preferably keeping functions in a seperate subfile. </p> <p>As a general rule for complext components, the component layer should not contain complex html fragments, rather organise complex html into subcomponents and pass down variables by props. In this way the component layer acts as a display layer. In simple components, treat them like subcomponents.</p> <p>The specific display intricacies of complex components are delegated to the subcomponent layer, promoting a hierarchical structure that enhances code organization and readability.</p>"},{"location":"patterns/#subcomponent-layer","title":"Subcomponent layer","text":"<p>In complex components, subcomponents can be used, subcomponents differ from external functions in that they are display modules with React code.</p> <p>Subcomponents are used to break code down to make it more readable, allow for specific unit testing if required, and make code more modular.</p> <p>Subcomponents should not contain state, all state should be contained either in the global, page or parent component layers dependant upon state needs. All required state should be passed down props and subcomponents should be Arrow functions with implicit returns.</p>"},{"location":"projects/","title":"Creating New Projects and Basic Setup","text":""},{"location":"projects/#vite","title":"Vite","text":"<p>Where possible, use Vite to create new React projects. It creates a more streamlined package than Create React App with faster internal server and build speeds.</p> <pre><code>npm create vite@latest\n</code></pre>"},{"location":"projects/#javascript-and-react","title":"JavaScript and React","text":"<p>Where possible create projects using JavaScript and React. Do not use SWC (Speedy Web Compiler) or TypeScript</p>"},{"location":"projects/#code-linting","title":"Code Linting","text":"<p>Use ESLint as the linter</p>"},{"location":"projects/#code-formatting-with-prettier","title":"Code Formatting with Prettier","text":"<p>Uses Prettier to format code. Run Prettier prior to commits to ensure code is consistantly formatted.</p>"},{"location":"projects/#unit-testing-with-jest","title":"Unit Testing with Jest","text":"<p>If using Unit Testing, use Jest to run these Test.</p>"},{"location":"projects/#general-dependency-guidelines","title":"General Dependency Guidelines","text":"<p>Try to limit the number of dependency pacakges to a minimum. Only use a package if it adds a feature that really saves substantial coding time.</p> <p>All dependencies installed should be added to a dependency.md </p>"},{"location":"solid/","title":"S.O.L.I.D.","text":""},{"location":"solid/#solid-principles-and-react","title":"SOLID Principles and React","text":"<p>SOLID principles as implimented in a React project can be summarised as follows.</p>"},{"location":"solid/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Highly important</p> <p>All components should strictly adhere to Single Responsibility Principle.</p> <p>Specific to React this means:</p> <ol> <li>All components should perform a single feature</li> <li>Complex components with multiple features should be broken up into a organisation layer and sub components for each feature</li> <li> <p>Basic program layer structure is as follows:</p> <p>a. Data management layer b. User interface layer c. React Component layer</p> </li> </ol>"},{"location":"solid/#open-closed-principle","title":"Open Closed Principle","text":"<p>Important</p> <p>In most cases components and subcomponents should be open to extension but closed to modification.</p> <p>Specific to React this means:</p> <ol> <li>Extension is provided by the use of props over use of state</li> </ol>"},{"location":"solid/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>Relatively important</p> <p>While functional components don't have class based inheritence like classical OOP languages, passing of props from parent to child props can still allow React components to obey the Liskov Subsitution principle.</p> <p>Specific to React this means:</p> <ol> <li> <p>When extending a component, props are passed through the parent to child, utilising composition over inheratance.</p> <pre><code>const Button = (name, function) {\n    &lt;div \n        className=\"button\" \n        onClick={function}\n    &gt;\n    {name}\n    &lt;/div&gt;\n}\n</code></pre> <p>to </p> <pre><code>const NeonButton = (name, function, colour) {\n    &lt;div className={colour}&gt;\n        &lt;Button name={name}\n            function={function} \n        /&gt;\n    &lt;/div&gt;\n}\n</code></pre> <p>The NeonButton extends the button Component by wrapping it in a div with an extra feature, the buttons props are passed down from the parent NeonButton to the Button, should the Button component be changed, the NeonButton will only need to be changed if Button requires additional props, and then only by passing props.</p> <p>The Liskov Subsititution Principle is a key design pattern for React.</p> </li> </ol>"},{"location":"solid/#interface-segregation-principle","title":"Interface segregation principle","text":"<p>Important</p> <p>Generally try to keep interface components simple, this concept works in tandem with the Single Responsibility Principle.</p> <p>Specific to React this means:</p> <ol> <li>Only ever pass relevant props to child components. Destucturing props at component layers helps with this.</li> </ol>"},{"location":"styling/","title":"CSS and styling","text":""},{"location":"styling/#css-location","title":"CSS location","text":"<p>CSS is to be held in seperate files and not inline.</p> <p>CSS is to be held at three levels:</p> <ol> <li>Global scoped CSS is to be stored in the App.css file, this includes the sites fonts and basic styling, such as themes. From a default Vite build, merge the index.css file into the App.css.</li> <li>Page specific CSS is to be stored in the appropriate Page.css file,</li> <li>Component specific CSS is to be stored at the Component level and it to be regulated by CSS modules to avoid potentially unwanted side effects.</li> <li>Reactive CSS are generaly to be engaged by Javascript changes to components class. </li> </ol>"},{"location":"styling/#css-conventions","title":"CSS conventions","text":""},{"location":"styling/#global-scope","title":"Global Scope","text":"<p>Global scope CSS include theme colours, colour scheme, fonts, basic html element styling etc.</p>"},{"location":"styling/#page-scope","title":"Page Scope","text":"<p>Page scoped CSS is generally concerned only with the display of components on the page.</p>"},{"location":"styling/#component-scope","title":"Component Scope","text":"<p>In accordance with microfrontends design patterns, Component.jsx are to have a component.css file associated with them. </p> <p>Vite by default supports CSS modules via Lightning CSS</p>"},{"location":"styling/#media-queries","title":"Media Queries","text":"<p>For responsive web design, utilise the design pattern of starting with css for phones, then moving onto pads, laptops and large screen media.</p> <p>Use the following breakpoints:</p> <pre><code>@media (min-width: 768px)\n@media (min-width: 1024px)\n@media (min-width: 1280px)\n</code></pre> <p>this will accomodate phones, pads, laptops and large screen monitors.</p>"},{"location":"tbh/","title":"State variables and logic","text":""},{"location":"tbh/#usestate","title":"useState","text":"<p>use the The general rules of useState when declaring variables.</p> <p>As a design pattern state should be used in one of three layers:</p> <ol> <li>Global variables (such as login details, API calls that are used in multiple pages etc) should be located in the App.jsx </li> <li>Page specific varaibles should be present in the appropiate Page.jsx</li> <li>Components that require their own state should have that stored in the appropite Component.jsx </li> <li>Subcomponents should not have their own state</li> </ol> <p>By having 3 distinct layers where state can be found, it should be realtively simplistic to determine where the state logic being passed to components dervives from</p> <p>In the interest of maintaining modularity, store state at the lowest level possible, excluding the subcomponent level. This approach ensures that state logic is localized to the most relevant component or layer, facilitating a clearer understanding of where the state is derived.</p>"},{"location":"tbh/#conditional-logic-styling","title":"Conditional logic styling","text":"<p>When implementing conditional logic in JavaScript, it is recommended to favor the ternary operator or switch statements over traditional if/else statements. The choice between these constructs should be made based on the specific use case and readability.</p> <p>Ternary operators provides a concise and easily readable alternative to if/else statements. It is particularly useful for simple conditional checks.</p> <p>Example:</p> <pre><code>    const result = condition ? 'Value for true' : 'Value for false';\n</code></pre> <p>In the case of complex case logic with multiple outcomes, switch statements provide clear readability and a default case for fallback/error handling.</p> <p>Example:</p> <pre><code>    switch (day) {\n      case 'Monday':\n        // Logic for Monday\n        break;\n    case 'Tuesday':\n        // Logic for Tuesday\n        break;\n    // Additional cases\n    default:\n        // Default case\n    }\n</code></pre> <p>Generally avoid if/else statements, as readability can be an issue.</p>"}]}